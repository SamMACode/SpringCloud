![1569252813951](https://raw.githubusercontent.com/SamMACode/springcloud/master/document/images/1569252813951.png)

## Build MicroService With Docker

> `Docker`包括一个命令行程序、一个后台守护进程，以及一组远程服务。它解决了常见的软件问题，并简化了安装、运行、发布和删除转件。这一切能够实现是通过使用一项`UNIX`技术，称为容器。

事实上，`Docker`项目确实与`Cloud Foundry`的容器在大部分功能和实现原理上都是一样的，可偏偏就是这剩下的一小部分不一样的功能成为了`Docker`呼风唤雨的不二法宝，这个功能就是`Docker`镜像。

与传统的`PaaS`项目相比，`Docker`镜像解决的恰恰就是打包这个根本性问题。所谓的`Docker`镜像，其实就是一个压缩包。但是这个压缩包中的内容比`PaaS`的应用可执行文件+启停脚本的组合就要丰富多了。实际上，大多数`Docker`镜像是直接由一个完整操作系统的所有文件和目录构成的，所以这个压缩包内容和本地开发、测试环境用的操作系统是完全一样的，这正是`Docker`镜像的精髓所在。

所以，`Docker`项目给`PaaS`世界带来的"降维打击"，其实是提供了一种非常便利的打包机制。这种机制直接打包了应用运行所需要的整个操作系统，从而保证了应用运行所需要的整个操作系统，从而保证了本地环境和云端环境的高度一致，避免了用户通过"试错"来匹配两种不同的运行环境之间差异的痛苦过程。

### 1. 容器技术基础概念

`Docker`容器中的运行就像是其中的一个进程，对于进程来说，它的静态表现就是程序，平常都安安静静地待在磁盘上。而一旦运行起来，它就变成了计算机里的数据和状态的总和，这就是它的动态表现。而容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个"边界"。

对于`Docker`等大多数`Linux`容器来说，`Cgroups`技术是用来制造约束的主要手段，而`Namespace`技术则是用来修改进程视图的主要方法。在`Docker`里容器中进程号始终是从`1`开始，容器中运行的进程已经被`Docker`隔离在了一个跟宿主机完全不同的世界当中。

**1）`Namespace`修改`docker`进程的视图**，在`linux`中创建线程的系统调用`clone()`函数，这个系统调用会为我们返回一个新的进程，并且返回它的进程号`pid`。而当我们用`clone()`函数调用和创建一个新进程时，就可以在参数中执行`CLONE_NEWPID`参数。这时，新创建的这个进程将会看到一个全新的进程空间，在这个进程空间里，它的`pid`为1。之所以所看到，是因为使用了"障眼法"，在宿主机真实的进程空间里，这个进程的`pid`还是真实的数值，比如`100`：

```c
int pid = clone(main_function, stack_size, SIGCHLD, NULL);
# 创建新的线程指定CLONE_NEWPID，返回新的进程空间的id
int pid = clone(main_function, stack_size, CLONE_NEWPID|SIGCHLD, NULL);
```

当然，我们还可以多次执行上面的`clone()`调用，这样就会创建多个`Pid Namespace`，而每个`namespace`里的应用进程都会被认为自己是当前容器里的第`1`号进程，它们既看不到宿主机里真正的进程空间，也看不到其它`PID Namespace`里的具体情况。除过刚才提到的`PID Namespace`，`Linux`操作系统还提供了`Mount`、`UTS`、`IPC`、`Network`和`User`这些`Namespace`用来对各种不同的进程上下文进行“障眼法”操作。

“敏捷”和“高性能”是容器相较于虚拟机最大的优势，也是它能够在`PaaS`这种更细粒度的资源管理平台上大行其道的重要原因。不过，有利也有弊，基于`linux namespace`的隔离机制相比较与虚拟化技术也有很多不足之处，其中最主要的问题就是：隔离得不彻底。首先，既然容器只是运行在宿主机上的一种特殊的进程，那么多个容器之间使用的就还是同一个宿主机操作系统内核。其次，在`linux`内核中，有很多资源和对象是不能被`namespace`化的，最典型的例子就是：时间（若在容器中应用程序改变了系统时间，则整个宿主机的时间都会被随之修改）。

**2）在介绍完容器的"隔离"技术之后，我们再来研究一下容器的"限制"问题**。虽然容器内的第`1`号进程在“障眼法”的干扰下只能看到容器里的情况，但是宿主机上它作为第`100`号进程与其他所有进程之间仍然是平等的竞争关系。虽然第`100`号进程表面上被隔离了起来，但是它所能够使用到的资源（如`CPU`、内存）却是可以随时被宿主机上的其他进程占用的。当然，这个`100`号进程自己也可能把所有资源吃光。这些情况，显然都不是一个“沙盒”应该表现出来的合理行为。

而`linux Cgroups`就是`linux`内核中用来为进程设置资源限制的一个重要功能，`linux Cgroups`的全称是`linux Control Group`。它的主要作用，就是限制一个进程组能够使用的资源上线，包括`CPU`、内存、磁盘、网络带宽等。此外，`Cgroups`还能够对进程进行优先级设置、审计，以及将进程挂起和修复等操作。在`/sys/fs/cgroup`下面有很多诸如`cpuset`、`cpu`、`memory`这样的子目录，也称为子系统。这些都是我这台机器当前可以被`Cgroups`进行限制的资源种类，而在子系统对应的资源种类下，就可以看到该类资源具体可以被限制的方法。如`cpu`的子系统，可以看到如下几个配置文件：

```shell
$ ls /sys/fs/cgroup/cpu
cgroup.clone_children cpu.cfs_period_us cpu.rt_period_us cpu.shares notify_on_release
cgroup.procs cpu.cfs_quota_us cpu.stat tasks
```

若熟悉`linux cpu`管理的话，就会在输出中注意到`cfs_period`和`cfs_quota`这样的关键字。这两个参数需要组合使用，可以用来限制进程在长度为`cfs_period`的一段时间内，只能被分配到总量为`cfs_quota`的`cpu`时间。在`tasks`文件中通常用来放置资源被限制的进程的`id`号，会对该进程进行`cpu`使用资源限制。除了`cpu`子系统外，`Cgroups`的每一项子系统都有其独有的资源限制能力，比如：`blkio`为块设置设置`I/O`限制，一般用于磁盘等设备。`cpuset`为进程分配单独的`cpu`核和对应的内存节点。`memory`为进程设置内存使用的限制。`linux Ggroups`的设计还是比较易用的，简单粗暴地理解，它就是一个子系统目录加上一组资源限制文件的组合。

**3）深入理解容器镜像，**在`docker`中我们创建的新进程启用了`Mount Namespace`，所以这次重新挂载的操作只在容器进程的`Mount Namespace`中有效。但在宿主机上用`mount -l`检查一下这个挂载，你会发现它是不存在的。这就是`Mount Namespace`跟其他`Namespace`的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载`(mount)`操作才生效的。在`linux`操作系统里，有一个名为`chroot`的命令可以帮助你在`shell`中方便地完成这个工作。顾名思义，它的作用就是帮你`"change root file system"`，即改变进程的根目录到你指定的位置。

对于`chroot`的进程来说，它并不会感受到自己的根目录已经被"修改"成`$HOME/test`了。实际上，`Mount Namespace`正是基于对`chroot`的不断改变才被发明出来的，它也是`linux`操作系统里的第一个`Namespace`。而这个挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫做：`rootfs`（根文件系统）。

需要明确的是，`rootfs`只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在`linux`操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。不过，正是由于`rootfs`的存在，容器才有了一个被反复宣传至今的重要特性：一致性。由于`rootfs`里打包的不只是应用，而是整个操作系统的文件和目录。也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。对一个应用程序来说，操作系统本身才是它运行所需要的最完整的"依赖库"。这种摄入到操作系统级别的运行环境一致性，打通了应用在本地开发和远程执行环境之间难以逾越的鸿沟。