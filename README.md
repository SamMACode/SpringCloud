[TOC]

#  微服务系统设计

`SamMACode/springcloud`项目是基于`spring cloud`构建的微服务系统，整个项目主要包括`api-gateway（服务网关）`、`config-repo（配置中心）`、`eureka（服务发现）`以及`order`、`product`、`user`3个微服务。 整个项目围绕用户购买商品并进行支付订单为简单应用场景，对于单体系统演化到微服务系统，在其中寻找业务边界并进行服务拆分，有很多值得深入思考的问题。

### 1. 什么是微服务，微服务系统设计的优点

#### 1）很小、专注于做好一件事，且具有自治性：

> “微服务就是一些协同工作的小而自治的服务，微服务很小，只专注做好一件事。”

对于传统的单体应用来说，每当业务人员有提出新的需求并为此开发了代码，这时所有的代码都会提交到同一代码库中，时间久了整个代码库中的代码量会非常大。代码库的代码量非常大会导致业务模块之间的边界很难维护，相似功能的代码开始在代码库中随机可见，使得修复`bug`以及开发新的需求都变得比较困难。

通常通过通过模块划分以及分层的方式来保证系统代码的内聚性，软件系统的内聚性是指将相关代码放在一起，在考虑使用微服务的时候，内聚性这一概念很重要。” 把因相同原因而发生变化的东西聚合在一起，而把因不同原因而产生变化的东西分离开来  “ 很好的阐述了内聚性这一概念。

在进行服务拆分的时代码库多少才算小，澳大利亚的`RealEstate.com.au`的`John Eaves`认为，一个微服务应该可以在两周内进行完全重写，这个经验法则在他所处的特定上下文是有效的。此外，也可以通过将大团队划分为多个小组（2到3个人）负责一个微服务系统。

> “一个微服务就是一个独立的实体，它可以独立的部署在`PAAS(Platform As A Service)`上，也可以作为一个操作系统进程存在。”

在微服务系统中，每一个服务都可以单独被部署（应尽量避免把多个服务部署到同一台机器上）。服务之间均通过网络调用进行通信，从而加强服务之间的隔离性，避免紧耦合。服务之间会暴露`API（Application Programming Interface）`，然后服务之间通过这些`API`进行通信。如果系统没有很好的解耦，那么一旦出现了问题，则微服务系统中所有的功能都将不可用。


#### 2）使用微服务架构的优势：

> ”微服务具有很多不同的好处，其中很多好处也适用于任何一个分布式系统。但相对于分布式系统或者面向服务的架构而言，微服务要更胜一筹，它会把这些好处推向极致。“

**系统技术的异构性**：在一个由多个服务相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。如对于社交网络来说，图数据库能够更好地处理用户之间交互操作，但是对于用户发布的帖子而言，文档数据库可能是一个更好的选择。微服务可以使我们更快的推进新技术，并理解新技术的好处。尝试新技术通常伴随着风险，尤其对于单体系统而言，采用一个新的语言、数据库或者框架都会对整个系统产生巨大的影响。对于微服务系统而言，可以尝试使用风险最小的服务采用新技术，即便出现问题可容易进行处理。

**提高系统的弹性**：弹性工程学的一个关键概念就是舱壁，如果系统中一个组件不可用了，但是并没有导致级联故障，那么系统的其它部分还可以正常运行。服务边界就是一个很显然的舱壁，在单块系统中如果服务不可用，那么所有的功能都会不可用，其可以通过在多台机器上部署相同的实例，在处理请求前对服务进行负载均衡处理。而微服务系统本身就能够很好的处理服务不可用和功能降级问题。

**系统易于扩展**：庞大的单块服务职能作为一个整体进行扩展，即使系统中只有一小部分存在性能问题，也需要对整个服务进行扩展。如果使用较小的多个服务，则可以只对需要扩展的服务进行扩展，这样就可以把那些不需要扩展的服务运行在更小的、性能稍差的硬件上。由于服务之间的界限比较明晰，可以很灵活针对个别系统进行服务扩展。

**简化系统部署**：在拥有几百万代码行的单块引用程序中，即使只修改了一行代码，也需要重新部署整个应用程序才能够发布该变更。这种部署的影响很大、风险很高，因此服务部署相关人员不敢轻易做部署。于是在实际操作中，部署的频率就会变得很低，在两次服务发布之间可能包含多个需求。这样导致当其中一个需求变更出现问题时，可能会导致整个新版本的代码部署失败。在微服务架构中，各个服务之间是独立部署的，这样可以快速针对特定部分的代码进行部署。如果是真的出现了问题，也只会影响一个服务，并且容易进行快速的回滚。`Amazon`以及`Netflix`等组织采用这种架构主要就是基于上述进行考虑的。

**与组织结构相匹配**：当团队是分布式的时候，问题就会更加明显，在小型代码库上工作的小团队更加高效。微服务架构可以很好地将架构与组织结构相匹配，避免出现多大的代码库，从而获得理想的团队大小以及生产力。服务的所有权也可以在团队之间迁移，从而避免异地团队的出现。



### 2. 对微服务进行建模、划分业务边界准则
#### 1）什么样的服务是好服务：
> 什么是好的服务？如果你之间尝试过`SOA`并且失败了，则肯定会关注于松耦合和高内聚，这两个概念在不同的上下文中被大量的使用，尤其在面向对象编程中。

**服务之间松耦合 **：如果做到了服务之间的松耦合，那么修改一个服务就不需要修改另一个服务。使用微服务最重要的一点是，能够独立修改及部署单个服务而不需要修改系统的其它部分。一个松耦合的服务应该尽可能少地知道与之协作的那些服务的信息。这也意味着应该限制两个服务之间不同调用形式的数量，因为除了潜在的性能问题之外，过度的通信可能会导致紧耦合。

**系统内部高内聚**：将相关的行为聚集在一起，把不相关的行为放在别处。如果想要修改某个行为的话，最好能够只在一个地方进行修改，然后就可以尽快的发布。如果需要在很多不同的地方做这些修改，那么可能就需要同时发布多个微服务才能交付这个功能。在多个不同的地方进行修改会很慢，同时部署多个服务风险也很高。所以，找到问题域的边界就可以确保相关的行为能放在同一个地方，并且它们会和其他边界以尽量松耦合的形式进行通信。

#### 2）界限微服务上下文关系：
`Eric Evans`认为任何一个给定的领域都包含多个界限上下文`（bounded context）`，每个界限上下文的东西分为两部分，一部分不需要与外部通信，另一部分需要则需要。每个上下文都有明确的接口，该接口决定了它会暴露那些模型给其它的上下文。一个由显式边界限定的特定职责，如果你想要从一个限界上下文中获取信息，或者向其发送请求，需要使用模型和它的显示边界进行通信。

一般来说，微服务应该清晰地和界限上下文保持一致。熟练之后，就可以省掉在单块系统中先使用模块的这个步骤，而直接使用单独的服务。然而对于一个新系统而言，可以先使用一段时间的单块系统，因为如果服务之间的边界搞错了，后面修复的代价会很大。所以最好能够等到系统稳定下来之后，再确定哪些东西应该作为一个服务划分出去。

#### 3）从业务功能考虑界限上下文：

当在思考组织内的界限上下文时，不应该从共享数据的角度来考虑，而应该从这些上下文能够提供的功能来考虑。建模服务时，应该将这些功能作为关键操作提供给其协作者（其他服务）。一开始你会识别出一些粗粒度的界限上下文，而这些上下文可能又包含一些嵌套的界限上下文。当考虑微服务的边界时，应该考虑比较大的、粗粒度的那些上下文，单后当发现合适的缝隙后，再进一步划分出那些嵌套的上下文。



